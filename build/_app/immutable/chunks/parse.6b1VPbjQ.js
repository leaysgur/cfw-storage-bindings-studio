var _=Object.defineProperty;var i=(e,o)=>_(e,"name",{value:o,configurable:!0});import{T as h,g as A}from"./runtime.PM082qKs.js";function E(e,o,c){if(e==null)return o(void 0),c&&c(void 0),h;const n=e.subscribe(o,c);return n.unsubscribe?()=>n.unsubscribe():n}i(E,"subscribe_to_store");const g=[];function k(e,o){return{subscribe:O(e,o).subscribe}}i(k,"readable");function j(e,o){return e!=e?o==o:e!==o||e&&typeof e=="object"||typeof e=="function"}i(j,"safe_not_equal");function O(e,o=h){let c=null;const n=new Set;function f(t){if(j(e,t)&&(e=t,c)){const u=!g.length;for(const s of n)s[1](),g.push(s,e);if(u){for(let s=0;s<g.length;s+=2)g[s][0](g[s+1]);g.length=0}}}i(f,"set");function r(t){f(t(e))}i(r,"update");function b(t,u=h){const s=[t,u];return n.add(s),n.size===1&&(c=o(f,r)||h),t(e),()=>{n.delete(s),n.size===0&&c&&(c(),c=null)}}return i(b,"subscribe"),{set:f,update:r,subscribe:b}}i(O,"writable");function V(e,o,c){const n=!Array.isArray(e),f=n?[e]:e;if(!f.every(Boolean))throw new Error("derived() expects stores as input, got a falsy value");const r=o.length<2;return k(c,(b,t)=>{let u=!1;const s=[];let l=0,p=h;const w=i(()=>{if(l)return;p();const y=o(n?s[0]:s,b,t);r?b(y):p=typeof y=="function"?y:h},"sync"),a=f.map((y,I)=>E(y,N=>{s[I]=N,l&=~(1<<I),u&&w()},()=>{l|=1<<I}));return u=!0,w(),i(function(){A(a),p(),u=!1},"stop")})}i(V,"derived");function z(e){let o;return E(e,c=>o=c)(),o}i(z,"get_store_value");const T=-1,m=-2,S=-3,D=-4,q=-5,B=-6;function G(e,o){return F(JSON.parse(e),o)}i(G,"parse");function F(e,o){if(typeof e=="number")return f(e,!0);if(!Array.isArray(e)||e.length===0)throw new Error("Invalid input");const c=e,n=Array(c.length);function f(r,b=!1){if(r===T)return;if(r===S)return NaN;if(r===D)return 1/0;if(r===q)return-1/0;if(r===B)return-0;if(b)throw new Error("Invalid input");if(r in n)return n[r];const t=c[r];if(!t||typeof t!="object")n[r]=t;else if(Array.isArray(t))if(typeof t[0]=="string"){const u=t[0],s=o==null?void 0:o[u];if(s)return n[r]=s(f(t[1]));switch(u){case"Date":n[r]=new Date(t[1]);break;case"Set":const l=new Set;n[r]=l;for(let a=1;a<t.length;a+=1)l.add(f(t[a]));break;case"Map":const p=new Map;n[r]=p;for(let a=1;a<t.length;a+=2)p.set(f(t[a]),f(t[a+1]));break;case"RegExp":n[r]=new RegExp(t[1],t[2]);break;case"Object":n[r]=Object(t[1]);break;case"BigInt":n[r]=BigInt(t[1]);break;case"null":const w=Object.create(null);n[r]=w;for(let a=1;a<t.length;a+=2)w[t[a]]=f(t[a+1]);break;default:throw new Error(`Unknown type ${u}`)}}else{const u=new Array(t.length);n[r]=u;for(let s=0;s<t.length;s+=1){const l=t[s];l!==m&&(u[s]=f(l))}}else{const u={};n[r]=u;for(const s in t){const l=t[s];u[s]=f(l)}}return n[r]}return i(f,"hydrate"),f(0)}i(F,"unflatten");export{m as H,S as N,D as P,T as U,q as a,B as b,V as d,z as g,G as p,k as r,E as s,F as u,O as w};
